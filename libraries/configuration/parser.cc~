/*
 * debug.cc
 *
 *  Created on: 8 mars 2013
 *      Author: hadrien
 */




#include <boost/config/warning_disable.hpp>
#include <boost/spirit/include/qi.hpp>
#include <boost/spirit/include/phoenix_core.hpp>
#include <boost/spirit/include/phoenix_operator.hpp>
#include <boost/spirit/include/phoenix_object.hpp>
#include <boost/fusion/include/adapt_struct.hpp>
#include <boost/fusion/include/io.hpp>

#include <vector>
#include <list>
#include <iostream>
#include <string>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

namespace client
{
  namespace qi = boost::spirit::qi;
  //namespace ascii = boost::spirit::ascii;
  namespace standard = boost::spirit::standard;

  ///////////////////////////////////////////////////////////////////////////
  //  Our moses struct
  ///////////////////////////////////////////////////////////////////////////
  struct shapeInfo
  {
    std::string name;
    std::vector<std::string> attributes;
  };

  struct trialInfo
  {
    int time;
    std::string name;
    std::vector<shapeInfo> shapes;
  };

  struct screenInfo
  {
    int	height;
    int	width;
  };

  struct sessionInfo
  {
    std::string name;
    std::string comment;

    int polarCoordonates; // Default No
    std::vector<screenInfo> screens; // Default Yes
    std::vector<trialInfo> trials;
  };

}

// We need to tell fusion about our struct
// to make it a first-class fusion citizen. This has to
// be in global scope according to official Boost Spirit tutorial.

BOOST_FUSION_ADAPT_STRUCT(
    client::shapeInfo,
    (std::string, name)
    (std::vector<std::string>, attributes)
)

BOOST_FUSION_ADAPT_STRUCT(
     client::screenInfo,
     (int, height)
     (int, width)
)

BOOST_FUSION_ADAPT_STRUCT(
    client::trialInfo,
    (int, time)
    (std::string, name)
    (std::vector<client::shapeInfo>, shapes)
)

BOOST_FUSION_ADAPT_STRUCT(
    client::sessionInfo,
    (std::string, name)
    (std::string, comment)
    (int, polarCoordonates)
    (std::vector<client::screenInfo>, screens)
    (std::vector<client::trialInfo>, trials)
)

namespace client
{
    ///////////////////////////////////////////////////////////////////////////////
    //  Our moses parser
    ///////////////////////////////////////////////////////////////////////////////
    template <typename Iterator>
    struct moses_parser : qi::grammar<Iterator, sessionInfo(), standard::space_type>
    {
      moses_parser() : moses_parser::base_type(session)
        {
    	  using qi::int_;
    	  using qi::lit;
    	  using qi::double_;
    	  using qi::lexeme;
    	  using standard::char_;
    	  using boost::fusion::vector;
    	  using qi::eol;

    	  word %= lexeme[ +(char_ - ' ' - "|" - ">" - ";" - "\n")];

		  shape %= ">"
			>> word
			>> +word
			;

		  trial %= "|"
			>> -int_
			>> word
			>> +shape
			>> ";"
			;

		  screen %= int_ >> "x" >> int_ >> "|";

		  session %=
			"session name="
			>> word
			>> "comment="
			>> word
			>> "polar="
			>> int_
			>> "screens="
			>> +screen
			>> +trial
			;

			}

		  qi::rule<Iterator, std::string(), standard::space_type> word;
		  qi::rule<Iterator, client::shapeInfo(), standard::space_type> shape;
		  qi::rule<Iterator, client::trialInfo(), standard::space_type> trial;
		  qi::rule<Iterator, client::screenInfo(), standard::space_type> screen;
		  qi::rule<Iterator, client::sessionInfo(), standard::space_type> session;
		};
}


////////////////////////////////////////////////////////////////////////////
//  Main program
////////////////////////////////////////////////////////////////////////////
int
main(int argc,
     char **argv)
{
    char const* filename;
    if (argc > 1)
    {
        filename = argv[1];
    }
    else
    {
        std::cerr << "Error: No input file provided." << std::endl;
        return 1;
    }
    std::ifstream in(filename, std::ios_base::in);
    if (!in)
    {
        std::cerr << "Error: Could not open input file: "
            << filename << std::endl;
        return 1;
    }
    in.unsetf(std::ios::skipws); // No white space skipping!
    std::string storage; // We will read the contents here.
    std::copy(
        std::istream_iterator<char>(in),
        std::istream_iterator<char>(),
        std::back_inserter(storage));

    using boost::spirit::standard::space;

    typedef std::string::const_iterator iterator_type;
    typedef client::moses_parser<iterator_type> moses_parser;
	client::sessionInfo emp2;

    moses_parser g; // Our grammar


    std::string::const_iterator iter = storage.begin();
    std::string::const_iterator end = storage.end();
    bool r = boost::spirit::qi::phrase_parse(iter, end, g, space, emp2);

    if (r && iter == end)
    {
        std::cout << "-------------------------\n";
        std::cout << "Parsing succeeded\n";
        std::cout << "-------------------------\n";
        return 0;
    }
    else
    {
        std::cout << "-------------------------\n";
        std::cout << "Parsing failed\n";
        std::cout << "-------------------------\n";
        return 1;
    }
}

